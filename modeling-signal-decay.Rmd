---
title: "Modeling signal decay functions"
author: "Sysbiolab Team"
date: "`r Sys.Date()`"
bibliography: bibliography.bib
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Package**: PathwaySpace `r packageVersion('PathwaySpace')`
<br/>

# Overview

In this tutorial, we demonstrate how to model signal decay functions targeted at specific nodes. Using a simple lattice graph, we illustrate how different decay functions influence the propagation of signals across a network. Nodes in this graph represent spots, providing an intuitive starting point for understanding how *PathwaySpace* methods can be used to capture behaviors in larger or more complex graphs from spatial transcriptomics data.s

# Setting basic input data

```{r Load packages - quick start, eval=TRUE, message=FALSE}
#--- Load required packages for this section
library(igraph)
library(ggplot2)
library(RGraphSpace)
library(PathwaySpace)
library(SpotSpace)
```

```{r Modeling signal decay - 1, eval=TRUE, message=FALSE}
# Create a lattice graph with igraph
g <- make_lattice(c(9, 9), directed = FALSE)
V(g)$name <- paste0("n",1:vcount(g))
gs <- GraphSpace(g, layout = layout_on_grid(g))
plotGraphSpace(gs, add.labels = TRUE)
```

```{r Modeling signal decay - 2, eval=TRUE, message=FALSE}
# Build a PathwaySpace object
ps <- buildPathwaySpace(gs)
```

# Setting a decay function

Next, we will set a linear decay model for all vertices. A decay factor (in `[0,1]`) indicates how much the signal decreases as a function of distance in pathway space. For example, at the `pdist` reference distance, the signal intensity will be the initial signal multiplied by `decay`. For further details on the available decay functions, refer to the documentation and code examples of the `weibullDecay()`, `expDecay()`, and `linearDecay()` functions.

```{r Modeling signal decay - 4, eval=TRUE, message=FALSE}
# Setting a linear signal decay model for all vertices
vertexDecay(ps) <- signalDecay("linear", decay = 0.001)
```

# Setting a distance unit

Before running a projection method, we also need to specify a distance unit for the signal decay function. This distance unit will affect the extent over which the convolution operation projects the signal, scaled to the coordinate space. Here we will use the center-to-center distance between spots.

```{r Modeling signal decay - 3, eval=TRUE, message=FALSE}
# Get distance to the nearest spot
near_df <- getNearestNode(ps)
pdist <- mean(near_df$dist)
# The 'pdist' is the average center-to-center distance between spots
pdist
```

# Running *PathwaySpace*

Now we project a random binary signal using the `circularProjection()` function.

```{r Modeling signal decay - 5, eval=TRUE, message=FALSE}
# Add a random binary signal
set.seed(10)
vertexSignal(ps) <- sample(c(0,1), gs_vcount(ps), replace = TRUE)
```

```{r Modeling signal decay - 6, eval=TRUE, message=FALSE}
# Running and plotting projections
ps <- circularProjection(ps, k = 1, pdist = pdist)
plotPathwaySpace(ps)
```

By assigning a new decay model to specific vertices, we can explore how signals propagate across the network under different rules. To illustrate, next we assign a Weibull decay function to vertex `n34`.

```{r Modeling signal decay - 7, eval=TRUE, message=FALSE}
# Setting a Weibull decay function for vertex 'n34'
vertexDecay(ps)[["n34"]] <- signalDecay("weibull", shape = 2, decay = 0.75)
```

```{r Modeling signal decay - 8, eval=TRUE, message=FALSE}
# Running and plotting projections
ps <- circularProjection(ps, k = 1, pdist = pdist)
plotPathwaySpace(ps, marks = "n34")
```

# Session information
```{r label='Session information', eval=TRUE, echo=FALSE}
sessionInfo()
```
