---
title: "Creating signal aggregation rules"
author: "Sysbiolab Team"
date: "`r Sys.Date()`"
bibliography: bibliography.bib
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Package**: PathwaySpace `r packageVersion('PathwaySpace')`
<br/>

# Overview

This tutorial demonstrates how to setup signal aggregation rules for *PathwaySpace* projections. Using a toy graph with five small islands, we illustrate how different aggregation functions can be applied to emphasize distinct patterns in the data.

# Setting basic input data

```{r Load packages - quick start, eval=TRUE, message=FALSE}
#--- Load required packages for this section
library(igraph)
library(ggplot2)
library(RGraphSpace)
library(PathwaySpace)
library(SpotSpace)
library(patchwork)
```

```{r Modeling signal decay - 1, eval=TRUE, message=FALSE}
# Create a simple graph with six islands
g <- rep(igraph::make_star(7, "undirected"), 5)
V(g)$name <- paste0("n",1:vcount(g))
gs <- GraphSpace(g, layout = layout_nicely(g))
plotGraphSpace(gs, add.labels = TRUE)
```

```{r Modeling signal decay - 2, eval=TRUE, message=FALSE}
# Build a PathwaySpace object
ps <- buildPathwaySpace(gs)
```

# Setting a decay function

Next, we will set a linear decay model for all vertices (for details see [**modeling signal decay**](modeling-signal-decay.html) section).

```{r Modeling signal decay - 4, eval=TRUE, message=FALSE}
# Setting a linear signal decay model for all vertices
vertexDecay(ps) <- signalDecay("linear", decay = 0.001)
```

...and then set a distance unit.

```{r Modeling signal decay - 3, eval=TRUE, message=FALSE}
# Get distance to the nearest nodes
near_df <- getNearestNode(ps)
pdist <- mean(near_df$dist)
# The 'pdist' is the average center-to-center distance between nodes
pdist
```

...and assign a numeric signal, here setting peak values at the central vertices or hubs.

```{r Modeling signal decay - 5, eval=TRUE, message=FALSE}
# Find hubs 
hubs <- degree(ps@graph)
hubs <- hubs[hubs>1]
# Add signal
vertexSignal(ps) <- 1
vertexSignal(ps)[names(hubs)] <- 2
# Vertex count
gs_vcount(ps)
```


# Running *PathwaySpace*

Now we project the signals using the `circularProjection()` function. Note that this function will project *vertex-signal positions* (or source points) to *null-signal positions* (or end points) across the *PathwaySpace* (see [**Figure 1A**](index.html)), so the resulting projections can be aggregated in different ways. In the examples below, we compare two approaches: the standard *arithmetic mean*, where all values contribute equally, and the *self-weighted (contraharmonic) mean*, where each value is weighted by its own magnitude.

```{r Modeling signal decay - 6, eval=TRUE, message=FALSE, out.width="100%"}
# Running and plotting projections
ps <- circularProjection(ps, k = gs_vcount(ps), pdist = pdist, aggregate.fun = mean)
p1 <- plotPathwaySpace(ps, theme = "th3")
wmean <- function(x){ weighted.mean(x, abs(x)) }
ps <- circularProjection(ps, k = gs_vcount(ps), pdist = pdist, aggregate.fun = wmean)
p2 <- plotPathwaySpace(ps, theme = "th3")
p1 + p2
```

These examples shows how changes in weighting (from equal weights to self-weights) can shift the mean toward the more dominant signals. Next, we assign new aggregation functions to explore different rules. The `max` function will also emphasize the dominant signals while the `min` function will highlight the regions where projections intersect between two source points. Note that the `k` parameter affects the aggregation, as it determines how many projected signals are considered at each end point. Except from cases where aggregation amins to highlight minimal values, we recommend using `k = gs_vcount(ps)` to capture contributions from all signals reaching the end points.

```{r Modeling signal decay - 7, eval=TRUE, message=FALSE, out.width="100%"}
# Running and plotting projections
ps <- circularProjection(ps, k = gs_vcount(ps), pdist = pdist, aggregate.fun = max)
p1 <- plotPathwaySpace(ps, theme = "th3")
ps <- circularProjection(ps, k = 2, pdist = pdist, aggregate.fun = min)
p2 <- plotPathwaySpace(ps, theme = "th3")
p1 + p2
```

# Session information
```{r label='Session information', eval=TRUE, echo=FALSE}
sessionInfo()
```

